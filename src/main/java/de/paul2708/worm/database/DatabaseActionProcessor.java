package de.paul2708.worm.database;

import de.paul2708.worm.columns.AttributeResolver;
import de.paul2708.worm.columns.ColumnAttribute;
import de.paul2708.worm.columns.generator.ValueGenerator;
import de.paul2708.worm.columns.properties.AutoGeneratedProperty;
import de.paul2708.worm.columns.properties.ForeignKeyProperty;
import de.paul2708.worm.columns.properties.LengthRestrictedProperty;
import de.paul2708.worm.repository.CrudRepository;
import de.paul2708.worm.repository.Repository;
import de.paul2708.worm.repository.actions.*;
import de.paul2708.worm.util.DefaultValueChecker;

import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;

public class DatabaseActionProcessor {

    private final Database database;
    private final Class<?> entityClass;

    public DatabaseActionProcessor(Database database, Class<?> entityClass) {
        this.database = database;
        this.entityClass = entityClass;
    }

    public Object process(DatabaseAction action) {
        AttributeResolver resolver = new AttributeResolver(entityClass);

        if (action instanceof SaveAction) {
            Object targetEntity = action.getMethodInformation().args()[0];

            // Generate values
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.isAutoGenerated() && DefaultValueChecker.isDefaultValue(targetEntity, column.getField())) {
                    ValueGenerator<?> generator = column.getProperty(AutoGeneratedProperty.class).createGenerator();
                    Object generatedValue = generator.generate();

                    column.setValue(targetEntity, generatedValue);
                }
            }

            // Check max length
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.hasMaximumLength()) {
                    String text = (String) column.getValue(targetEntity);

                    if (text.length() > column.getProperty(LengthRestrictedProperty.class).length()) {
                        throw new IllegalStateException("The value of field %s is too long.".formatted(column.fieldName()));
                    }
                }
            }

            // Handle foreign keys
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.isForeignKey()) {
                    CrudRepository foreignRepository = Repository.create(CrudRepository.class, column.getProperty(ForeignKeyProperty.class).getForeignKey(),
                            database);
                    Object foreignEntity = foreignRepository.save(column.getValue(targetEntity));

                    column.setValue(targetEntity, foreignEntity);
                }
            }

            return database.save(resolver, targetEntity);
        } else if (action instanceof FindAllAction) {
            return database.findAll(new AttributeResolver(entityClass));
        } else if (action instanceof FindByIdAction) {
            return database.findById(resolver, action.getMethodInformation().args()[0]);
        } else if (action instanceof DeleteAction) {
            Object targetEntity = action.getMethodInformation().args()[0];

            Object key = getField(resolver.getPrimaryKey().fieldName(), targetEntity);

            if (key == null) {
                throw new IllegalArgumentException("Cannot access primary key");
            }

            database.delete(resolver, targetEntity);

            return null;
        } else if (action instanceof FindByAttributesAction) {
            String methodName = action.getMethodInformation().method().getName();
            String[] columnNames = methodName.replace("findBy", "").split("And");
            Map<String, Object> attributes = new HashMap<>();

            for (int i = 0; i < columnNames.length; i++) {
                attributes.put(columnNames[i], action.getMethodInformation().args()[i]);
            }


        }

        throw new IllegalArgumentException("Did not handle database action %s".formatted(action.getClass().getName()));
    }

    private Object getField(String fieldName, Object object) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);

            return field.get(object);
        } catch (IllegalAccessException | NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }
}
