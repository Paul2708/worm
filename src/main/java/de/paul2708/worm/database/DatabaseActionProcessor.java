package de.paul2708.worm.database;

import de.paul2708.worm.columns.AttributeResolver;
import de.paul2708.worm.columns.ColumnAttribute;
import de.paul2708.worm.columns.generator.ValueGenerator;
import de.paul2708.worm.columns.properties.AutoGeneratedProperty;
import de.paul2708.worm.columns.properties.ForeignKeyProperty;
import de.paul2708.worm.columns.properties.LengthRestrictedProperty;
import de.paul2708.worm.repository.CrudRepository;
import de.paul2708.worm.repository.Repository;
import de.paul2708.worm.repository.actions.*;
import de.paul2708.worm.util.DefaultValueChecker;
import de.paul2708.worm.util.Reflections;

import java.lang.reflect.Field;
import java.util.*;

public class DatabaseActionProcessor {

    private final Database database;
    private final Class<?> entityClass;

    public DatabaseActionProcessor(Database database, Class<?> entityClass) {
        this.database = database;
        this.entityClass = entityClass;
    }

    public Object process(DatabaseAction action) {
        AttributeResolver resolver = new AttributeResolver(entityClass);

        if (action instanceof SaveAction) {
            Object targetEntity = action.getMethodInformation().args()[0];

            // Generate values
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.isAutoGenerated() && DefaultValueChecker.isDefaultValue(targetEntity, column.getField())) {
                    ValueGenerator<?> generator = column.getProperty(AutoGeneratedProperty.class).createGenerator();
                    Object generatedValue = generator.generate();

                    column.setValue(targetEntity, generatedValue);
                }
            }

            // Check max length
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.hasMaximumLength()) {
                    String text = (String) column.getValue(targetEntity);

                    if (text.length() > column.getProperty(LengthRestrictedProperty.class).length()) {
                        throw new IllegalStateException("The value of field %s is too long.".formatted(column.fieldName()));
                    }
                }
            }

            // Handle foreign keys
            for (ColumnAttribute column : resolver.getColumns()) {
                if (column.isForeignKey()) {
                    CrudRepository foreignRepository = Repository.create(CrudRepository.class, column.getProperty(ForeignKeyProperty.class).getForeignKey(),
                            database);
                    Object foreignEntity = foreignRepository.save(column.getValue(targetEntity));

                    column.setValue(targetEntity, foreignEntity);
                }
            }

            return database.save(resolver, targetEntity);
        } else if (action instanceof FindAllAction) {
            return database.findAll(new AttributeResolver(entityClass));
        } else if (action instanceof FindByIdAction) {
            return database.findById(resolver, action.getMethodInformation().args()[0]);
        } else if (action instanceof DeleteAction) {
            Object targetEntity = action.getMethodInformation().args()[0];

            Object key = getField(resolver.getPrimaryKey().fieldName(), targetEntity);

            if (key == null) {
                throw new IllegalArgumentException("Cannot access primary key");
            }

            database.delete(resolver, targetEntity);

            return null;
        } else if (action instanceof FindByAttributesAction) {
            String methodName = action.getMethodInformation().method().getName();
            String[] columnNames = methodName.replace("findBy", "").split("And");
            Map<ColumnAttribute, Object> attributes = new HashMap<>();

            for (int i = 0; i < columnNames.length; i++) {
                ColumnAttribute attribute = getColumnByTransformedName(resolver, columnNames[i]);
                attributes.put(attribute, action.getMethodInformation().args()[i]);
            }

            Collection<Object> entities = database.findByAttributes(resolver, attributes);
            Class<?> returnType = action.getMethodInformation().method().getReturnType();

            if (Reflections.isList(returnType)) {
                return new ArrayList<>(entities);
            } else if (Reflections.isSet(returnType)) {
                return new HashSet<>(entities);
            } else if (returnType.equals(Optional.class)) {
                if (entities.isEmpty()) {
                    return Optional.empty();
                }
                if (entities.size() == 1) {
                    return Optional.of(entities.iterator().next());
                }

                throw new RuntimeException("Expected %s but retrieved multiple entities".formatted(Optional.class));
            }
        }

        throw new IllegalArgumentException("Did not handle database action %s".formatted(action.getClass().getName()));
    }

    private Object getField(String fieldName, Object object) {
        try {
            Field field = object.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);

            return field.get(object);
        } catch (IllegalAccessException | NoSuchFieldException e) {
            throw new RuntimeException(e);
        }
    }

    private ColumnAttribute getColumnByTransformedName(AttributeResolver resolver, String transformedName) {
        for (ColumnAttribute column : resolver.getColumns()) {
            if (column.getTransformedColumnName().equals(transformedName)) {
                return column;
            }
        }

        throw new IllegalArgumentException("Could not find a matching column with the name %s"
                .formatted(transformedName));
    }
}
